### 一、概述

SOA是携程框架组开发的面向服务的基础框架，其本质目标还是业务对齐和敏捷

简单来说就是可以透过网络上的通用协议调用另一个应用软件组件执行、运作，让调用者获得服务

其实说白了就是一个RPC的服务，里面有一个注册中心Artemis



学习怎么通过SOA去构建自己的服务



SOA框架主要组件

1、高性能Restful框架

2、契约驱动代码生成

3、服务治理系统

4、服务注册表



### 二、开发SOA服务

**创建一个SOA服务流程**

这个基本上两步走：

1、先创建新应用

2、然后再SOA上注册服务即可

3、建议采用Baiji框架去实现一个服务



**编写契约**

目前契约从SOA迁移到了MOM系统，在那里去写契约

先创建契约项目，然后创建接口，最后生成契约

逐步淘汰项目中直接引入代码的方式，全部切换到使用maven interface jar的方式进行项目迭代



**代码生成Demo项目**

http://start.fx.ctripcorp.com/starter/#step1这个是初始化的脚手架网站

下载后我们将pom中的默认依赖改掉，并且将原契约实现类将class改成自己的服务名

然后configuration里也修改



**springboot服务端开发**

引入MOM构建的服务端依赖---然后添加service实现类----添加SOA配置类



**客户端编写**

1、先引入SOA的mom服务契约（maven）

2、调用服务端



**SOA点火**

其实不仅是SOA，很多服务依赖组件如Redis、QMQ等都需要点火过程，即在服务正式提供功能前保证所有依赖第三方组件正常初始化和预热完毕，如果出错立即停止该服务并通知用户回退，



### **三、服务配置**

我们可以在SOA Portal里对我们的服务进行配置

配置分应用配置和服务配置，服务配置适用单个服务，而应用配置则是对该应用下所有SOA服务都生效

服务可配置的点有很多，我们一个个学习

1、服务预热

Java应用在刚开始启动的时候处理响应速度会很慢，只有当热点代码被执行了一定次数以后，响应速度才会到达一个稳定状态，由于Java慢启动现象的存在，多数情况下我们有必要对Java应用进行预热，防止出现大量的慢请求

过程：

在机器启动后，将先进入预热阶段，时间由预热时长决定

预热阶段时流量会根据预热算法逐步增加（无特殊需要推荐默认的线性算法）

预热结束后，机器将进入稳定阶段，流量将保持均匀



2、黑白名单

黑名单：启用后对在黑名单里的客户端访问直接拒绝，返回403Frobidden

白名单：启用后对不在白名单里的客户端访问直接拒绝，返回403



3、限流

防止调用方请求量突然增加而导致服务端压力增大

触发条件：连续10s的请求数超过了单机预定设置的限流值，则框架直连返回429，不反序列化请求，不进入服务业务实现处理，知道连续10s内请求小于限流值，类似滑动窗口的实现



- 服务限流 到达当前服务 所有操作的请求
- 操作限流 到达当前服务下 某个特定操作的请求



- 单机限流 作用于服务端单机
- 集群限流 仅支持服务级别限流



4、流量分配

- 由多条配置的路由策略组成
- 每条路由策略应指明 路由规则 以及命中后如何分配流量





**小结**

使用SOA的几个关键点

首先是申请好应用和服务，接着呢



然后定好契约后进行服务开发，开发主要是引入maven依赖，然后写服务类以及SOA配置



开发完后即客户端开发，也是引依赖然后getInstance获取到实例，调用即可





### 四、原理剖析

携程内部服务多，目前内部采用SOA这种框架将业务进行解耦，我们分成以下角色

- SOA  面向服务的架构
- Server 服务提供方
- client 服务调用者
- 契约 规范数据交换方式和接口定义，独立于语言和操作系统平台，是一种通用的协议，根据契约文件可以生成相同服务接口的不同语言实现，内部推荐BJSC契约
- 序列化与反序列化 
- 服务注册与寻址 因为实际环境下，服务端可能部署在集群上，而客户端也在不同机器，我们通过Artemis注册中心来维护，实时更新服务信息和路由信息，并提供了运维API



**Artemis与服务端、客户端的交互**

服务端启动时，会与注册中心建立WebSocket的长连接，并将自身的服务信息注册到注册中心，服务实例启动完成后每5s调用自身健康接口进行自检，自检成功向注册中心发送心跳包，如果注册中心没有接收到心跳包会认为这个实例不健康，会踢出集群

客户端初始化时也会与Artemis建立webSocket的长连接，通过服务标识获取到对应的服务调用信息，注册中心会自动实时把路由和实例的变化信息推送给客户端



**熔断**

服务端熔断： 服务端接口在处理请求大量出错/变慢 会出发服务端熔断 这时接口会直接返回熔断错误 来保护服务提供者其他接口不受影响

客户端熔断：客户端调用某个接口大量出错/变慢，发送客户端熔断，这时不会再发出请求而是直接抛出熔断异常，来保护客户端本身和依赖该客户端的其他程序，避免发生雪崩效应



**限流**

服务端通过滑动窗口算法来控制最近10s的访问量，对于超出访问量的请求，服务端会直接返回429，目前SOA Portal支撑多种限流方式

IP直连：通过域名访问时其实内网请求会跟外网一样，先经过硬件LB，再走SLB最终到达服务端，但其实内网没必要这样，直接根据IP地址直接访问服务端机器即可

分组路由：一个Service可以部署在不同的实例，可以对实例进行分组，并通过路由策略控制client访问的分组



**系统架构**

![image-20231202142440177](D:\Users\haoxiang_zhang\AppData\Roaming\Typora\typora-user-images\image-20231202142440177.png)

- 客户端内包含一个Ribbon组件，会根据实例信息和路由信息选择一个服务实例，做负载均衡
- 服务端、客户端和Artemis通过WebSocket长连接进行双向通信
- 数据请求方式是基于Http协议的请求-响应模式，客户端通过IP直连的方式想服务端发起请求



### 五、应用场景

RPC还是适合那种实时的、有结果依赖的，这种一问一答的远程调用比较适合SOA框架，例如下单、查单，查询用户信息等场景，在业务上是同步的



下面有两个场景：

1、不要求实时性，没有结果依赖的信息传递，只需要告知事件发生的场景，比较适合消息框架，即QMQ

2、需要定时执行的任务 比较适合Job框架













