### 经典场景：

1、简单 KV set get

2、原子性 事务支持 将多个redis命令合一起

3、库存秒杀 CAS乐观锁



现在CRedis已经支持TRocks相关功能

我们使用CRedis的客户端进行操作，CRedis的客户端支持同步和异步两种操作方式





## Redis原理

### 数据结构

1、动态字符串 SDS

要知道Redis里字符串里用的还是挺多的，然后Redis又是C语言写的嘛

但是C语言字符串存在很多问题：

比如获取字符串长度需要运算，非二进制安全（末尾有结束符），不可修改

Redis构建了简单动态字符串SDS作为String的底层实现



SDS结构体 C语言struct

元数据：保存 申请空间、使用空间、头类型

SDS具备动态扩容的能力，申请内存空间：

- 如果新字符串小于1M 申请两倍+1
- 如果大于1M 申请扩容后空间+1M+1



这样好处在于二进制安全，因为你的头信息指明了使用到的长度，此外方便获取字符串长度

并且减少内存分配次数，有预分配功能



2、Dict字典

因为Redis其实是一个键值对的数据库，我们通过Dict去实现键与值的映射关系，

那么Dict的实现主要是哈希表，然后每个哈希节点保存了key、value、指针

其实底层原理是很类似于hashmap的



3、RedisObject

在Redis里 任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，所以在Dict的哈希节点，保存的只是key、value的指针

那么为什么要做这一层封装呢？我们知道Redis是通过dict来维护一个database内的映射关系的，而dict的key是字符串，固定用sds来表示就可以了，但是value的类型有很多，为了在dict能存储不同类型，封装了一层RedisObject

这个RedisObject内，元信息有对象类型（五种基本）、底层编码、lru、引用计数



### 网络模型

首先要理解用户态和内核态，注意这里以linux操作系统讲述，因为Redis也没有提供window的安装包

那么对于linux为内核的操作系统来说，我们的应用是没法直接访问硬件的，所以我们要借助内核的能力去访问一些系统的能力

但是内核本身来说也是一个应用，它也需要内存、cpu等资源，而用户应用也需要，所以我们需要将用户和内核隔离开，于是将进程的寻址空间划分成内核空间、用户空间

**寻址空间**

应用程序和内核都不能直接访问物理内存，而是分配一些虚拟内存映射到物理内存，程序通过虚拟地址访问

用户空间只能执行一些受限的指令，必须通过内核的接口来访问内核空间可以执行特权命令，此时需要在用户态和内核态进行切换

linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区，写数据时将用户缓存数据拷贝到内核缓冲区然后写入设备，读数据时从设备读到内核缓冲区，再拷贝到用户缓冲区



**IO模型**

在UNIX网络编程归纳了五种IO模型

本质用户空间读取数据其实两个过程

1、等待数据就绪

2、从内核缓冲区把数据拷贝到用户缓冲区



FD：文件描述符 用来关联linux内的一个文件 因为在linux里有个设计理念叫万物皆文件

而所谓的IO多路复用本质是利用一个线程监听多个FD，在某个FD的IO事件就绪时通知，避免无效的阻塞等待，从而充分利用CPU资源

过程：

用户进程系统调用函数，指定监听FD集合，同时阻塞等待

然后就绪时将数据拷贝到用户空间

IO多路复用可以保证 读取数据时数据一定存在

常见的实现方式有：

- select
- poll
- epoll

三者主要区别是：

select poll在数据就绪后，会把监听的整个FD都返回，这样我们还需要再去遍历FD列表看哪些是准备好的，从时间复杂度角度上看是On

而epoll这种方式 内核准备好了后会把准备好的数据都返回 省去了遍历的操作 O1 常数级别



具体聊聊epoll的多路复用实现：

维护了一个红黑树保存要监听的FD，有一个链表维护就绪的FD

1、基于红黑树保存要监听的FD，保证即使监听的FD数量很多 增删改查效率都非常高

2、通过callback回调的机制监听红黑树上的FD 一旦就绪加入链表

3、epoll返回的仅仅是链表，即就绪的FD，这样用户进程就不需要再去遍历一遍，而select、poll其实返回的是FD整个数组，你还是需要去遍历一遍 看其中哪些就绪





**Redis是单线程还是多线程**

结论是 如果是Redis的核心业务部分（命令处理），答案是单线程

如果是整个Redis，那么是多线程，这里就有两个关键节点

- 4.0V 引入多线程异步处理一些耗时较久的任务 例如大Key的删除
- 6.0V 在核心网络模型引入多线程 进一步提高对多核CPU的效率

为什么？因为Redis的性能瓶颈是网络延迟而不是执行速度，多线程首先是导致过多的上下文切换带来不必要的开销，其次还会带来线程安全问题



Redis的网络模型的本质是基于epoll的IO多路复用+事件派发这种机制，当有对应的IO事件发生，例如客户端请求连接、或是连接建立后请求命令执行，或是Redis执行完后任务的写回，当FD就绪后会派发给响应的处理器进行处理。

以客户端连接为例，当多路复用程序发现server socket有可读事件，说明是客户端请求连接，会交给连接应答处理器，它会接收客户端socket，注册客户端FD到多路复用程序，这样这个客户端后续的执行命令请求会被多路复用程序给监听到





**通信协议**

Redis是C/S架构，服务端和客户端的通信走RESP协议

这是Redis基于TCP协议设计出的，协议非常简单高效

这种简单高效的通信协议很方便Redis快速读取、解析命令，方便Redis能快速处理和响应大量的请求



**内存管理**

注意Redis是基于内存存储，然而单节点的Redis内存不宜过大，会影响持久化和主从同步性能

我们可以修改配置文件设置Redis最大内存，然后Redis有两大内存回收机制



1、内存过期

即通过expire命令给Redis的key设置过期时间，Redis对于这类设置了TTL的key有两种删除策略

一是访问一个key时检查该key的存活时间，如果过期才删除

二是周期性抽样部分key，过期删除

如果实时删除的话，那需要对每个key设置定时任务，对cpu压力太大



2、内存淘汰

有时候Redis的key还是很多，需要主动挑选部分key删除

有八种策略

random、lru、lfu * TTL、ALL  = 6种 + 不淘汰、比较剩余TTL值

LRU是最少最近使用 LFU是最少频率使用

RedisObject里保存了相应的值为参考







