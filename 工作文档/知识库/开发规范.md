### 数据安全

公司的数据是分用户数据C、商业数据B、公司数据E三个类别

重要性四个类别聪L1到L4，L4重要性最高



如果需要将生产数据同步到测试环境，需要脱敏审核后才能同步

http://xshift.rb.ops.ctripcorp.com/#/dbaudit（Xshift工具）



业务安全涉及风控 需要提交审核：

http://aqps.portal.infosec.ctripcorp.com/submit



禁止含有问题组件的镜像发布到生产



### 漏洞

信安会把发现的漏洞报送到同一管理平台，一致未修复的漏洞会自动逐级升级最终到CTO

例如Sql注入，我们可以采用参数化查询，例如mybatis里用#来防止sql注入

xss攻击，窃取对话目标cookies，获取身份凭证登录系统



### 环境

FAT：开发测试环境

FWS：公共测试环境

LPT：性能测试环境

UAT：集成测试环境

PROD：生产环境

其中FAT、FWS、LPT这些环境没有隔离，可以相互访问，调用方在选择服务提供方的实例时，会优先选择相同子环境的服务实例，如果相同子环境实例不存在，就fallback到FWS环境的实例





### 应用运维

IDC：数据中心，部署服务器和相关设施的场所

DR：灾备，一个应用在多个IDC部署，确保IDC故障时应用依然能正常提供服务

GSLB：全局服务器负载均衡器，用于各个IDC之间负载均衡，与DR密切相关

LB:负载均衡器，负责进行负载均衡的硬件设备

访问入口：应用对外提供的一个入口



### 应用类型

Application：通过UI对外提供访问的应用

Service：通过API方式提供访问的应用

Job：定时执行特定操作的应用



### 信息安全规范

**安全域**

Internet：公网

Office：办公环境

production：生产环境

Test：测试环境



**名词**

应用：一个可以独立运行并完成特定功能的程序单元

APPID：应用的唯一标识

Pool：一组服务器的集合

Group：在一个Pool上部署的一个应用的实例





目前公司要求代码必须通过merge request合并入默认分支，不允许直接将代码push到默认分支



**堡垒机&金丝雀**

堡垒机是指在发布过程中第一台被发布拉出的机器，上面运行的是当前所要发布的镜像，由于是拉出的状态不接入流量，可以进行堡垒测试验证程序的严重性

金丝雀发布的差别在它是拉入集群的，会接入生产流量，我们在这里观察真实流量下程序是否可靠





**访问入口SLB**

没有特殊需求一般走HTTP，安全域的选择上如果是application类型选择gwpublic安全域，可以用办公PC访问，一般是站点类应用，service类型应用选择gwinternal安全域，只能由生产环境服务器访问



**创建DR**

在原有集群创建好访问入口后（SLB、group配置），通过Captain直接生成域名DR的Group





**应用下线**

下线访问入口（确认流量很小）

把实例缩容至0

group删除

captain删除应用





### 开发安全和发布规范

目前除了一般接口的未授权访问，更多的还是SOA未授权开放到了内网

因为很多SOA服务是在内网被调用的，所以无需鉴权，但如果堡垒到了外网，就会造成未授权访问

如果内网服务不小心开通了H5-Gateway，就会将整个内网服务的接口暴露到外网，造成未授权访问



### Java开发规范

对于POJO类中的布尔类型变量名，不要加is前缀，否则部分框架解析会引起序列化错误

常量要大写+下划线 如果用到了通用的设计模式要在类名里体现

方法设计：方法尽量不要超过100行 并且如果长度超过8000个字节码时不会被JIT编译成二进制码的

Object的equals方法容易抛NPE，建议有确定值的对象来调用equals

相同包装类对象之间值的比较用equals 有缓存

序列化类新增属性时请不要修改serialVersionUID，避免反序列化失败，如果完全不兼容升级，避免混乱再修改

构造函数如果有很多参数，且有多种参数组合时，推荐使用Builder模式，例如：

Executor executor = new ThreadPoolBuilder().coreThread(10).queueLenth(100).build();



基本类型

数字取模的结果不一定是正数，负数取模的结果仍然为负数

自动拆箱有NPE的风险

当然包装类型有好有坏，技术领域没有真正的银弹，Integer24字节，int4字节，但Integer能表达Null语义，并且集合和泛型都需要包装类型



推荐使用正则表达式的预编译功能，可以有效加快正则匹配速度，例如：

*//在某个地方预先编译Pattern，比如类的静态变量*
 private static Pattern pattern = Pattern.compile("[a-zA-Z]+");

*//真正使用Pattern的地方*
result = pattern.matcher("abc").matches();

我们把编译好的串作为静态变量，这样可以有效加快正则匹配速度



集合处理

主要重写equals就必须重写hashcode，对于set、hashmap key，必须重写equals和hashcode

在使用集合转数组的方法，必须使用集合的toArray(T[] array)方法，传入类型完全一样的数组大小是list.size例如：
List<String> list = new ArrayList<String>(2);
list.add("guan");
list.add("bao");
String[] array = new String[list.size()];
array = list.toArray(array);



在foreach里，其实是iterator的语法糖，所以如果需要对元素remove、add，要用Iterator的方式



推荐使用entrySet遍历，而不是keySet，因为keySet其实是遍历了两次，一次是转Iterator，另一次是取v



**并发处理**

高并发时同步调用应该考虑锁的性能损耗，锁的粒度应该尽可能小



volatile解决多线程内存不可见问题，对于一写多读是可以解决变量同步问题，但如果是多写同样无法解决线程安全问题



正确停止线程：

Thread.stop()不推荐使用，强行的退出太不安全

Thread.interrupt

停止线程池：Executor.shutdown不允许提交新任务，等待当前任务以及任务执行完退出



**异常处理**

可以通过预检查规避的异常不应该通过catch来解决，比如空指针、下标越界这样的

常见异常的消耗大，对大段代码进行try-catch，不利于定位，应该分开处理

捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃它，那还不如抛给它的调用者，最外层的业务使用者必须处理





**控制语句**

避免采用取反逻辑，不利于快速理解，并且取反逻辑的写法必然存在对应的正向逻辑写法







### 踩坑点

1、Math.abs()在特殊情况下会返回负值

```
Math.abs(Integer.MIN_VALUE)` 或 `Math.abs(Long.MIN_VALUE)` 分别返回的是 `Integer.MIN_VALUE` 和 `Long.MIN_VALUE
```

2、SimpleDateFormat非线程安全，一般不建议定义为static，或是这样用

private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {
    @Override
    protected DateFormat initialValue() {
        return new SimpleDateFormat("yyyy-MM-dd");
    }
};

3、getResourceAsStream在class和classLoader上执行有区别



### Git分支管理

- master 主分支

- develop 开发主分支 所有分支用这个来创建自己的开发分支 只做合并操作

- feature-xxx 功能开发分支 在develop上创建分支 以自己开发功能模块命名，功能测试正常后合并到develop

- feature-xxx-fix 功能bug修复分支，分支合并后发现bug 于是在develop上创建修复

- hotfix---xxx紧急bug修复 在master上创建合并

  

master负责上线版本的迭代

develop负责记录相对稳定的版本

release用于代码上线准备，分支从develop创建，上线前需要将release分支合并到master和develop

















