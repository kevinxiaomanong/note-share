### 一、泛型的妙用

是这样，在对表数据做缓存拿去数据的时候，因为不同表映射的对象是不一样的，所以我们最初封装返回对象是List，这导致后续接stream的时候，因为没有泛型信息过滤条件走不下去

其实这里就是一个非常典型的泛型，这里呢适用方法泛型，即你传入A类型我就给你返回List<A>的集合

![image-20231225165939970](D:\工作文档\知识库\assets\image-20231225165939970.png)



### 二、lambda表达式的内部规则

1、为什么循环里的lambda异常处理不可以被优化到外部?

我们说Lambda表达式是一个函数式接口的实例，它可以被视为一个函数或方法，在Java里是不是函数或方法抛出的异常需要被显式地捕获或声明，因此，Lambda表达式内部抛出的异常也需要被捕获或声明，这也是为什么我们在Lambda表达式外部用try-catch或是声明式抛出，编译还是会报错，因为内层的方法是没有任何异常捕获和声明的



2、为什么在Lambda表达式内部，使用到的局部变量必须是final或事实上的final（即变量值不可更改），这是因为lambda表达式的执行可能是在一个新的线程或延迟执行的情况下，为了保证线程安全，声明为final或事实上的final能保证在多线程环境下Lambda表达式执行的线程安全



### 三、jacoco

即Java Code Coverage 是一个用于计算Java代码覆盖率的开源工具，它可以帮助开发和测试人员分析代码的覆盖情况

可以与各种构建工具Maven、Gradle或是IDE（Eclipse、IDEA）集成使用，



### 四、关于join拼接的写法优化

return Joiner.*on*(*SEPARATOR_COMMA*).skipNulls()
        .join(labels.stream().map(UserPortraitLabel::getLabelId).collect(Collectors.*toList*()));



















