最后梳理一下整个流程：

首先 项目启动时 通过我们实现的VI插件预热功能 去初始化localcache，

接着我们查询时 直接获取localcache 在JVM里进行一系列的join、filter、sort、page之后返回

当用户进行更新操作时，我们会同步对localcache进行更新



我们重点关注一下更新这部分

因为我们都是基于



最后我们需要





### 方案评估

1、性能提升

这里用Jmeter测试时 要注意 不能用单个用户测 肯定是要不同用户去测

那么问题来了？怎么测呢

单个用户测还是不准的，我们应该去模拟100个不同的用户去测试

怎么测呢？目前方案是改造一下接口 加个username进去 然后cookie复用一个就好 保证能通过登录校验即可



测试发现：

当并发量很大的时候，因为我们这个方案是很消耗系统CPU资源的，因为相当于你是在拿服务器的资源在跑sql任务的，所以当并发量大的时候，系统是



2、内存消耗



3、缓存一致性



4、缓存更新策略

删除旧的 然后添加新的



5、缓存命中率

这里不用担心，因为我们是全量拉取，缓存命中率是百分之百的















