### Week1 11.20-11.27

day1 11.20

上午搬东西换工位 

每周一下午组内周会

周五、周末、冻结期最好是不要发生产



leader交流



晚上有个需求：

申请一个app id， 然后建一个git仓库，再建一个SOA服务，captain流水线绑定一下，然后moon契约配一下，设计一下表

appid：100047577

SOACode：30610 

git仓库：git@git.dev.sh.ctripcorp.com:haoxiang_zhang/poidemand.git

captain：https://captain.release.ctripcorp.com/app/100047577/info

SOA：![image-20231120183140384](D:\Users\haoxiang_zhang\AppData\Roaming\Typora\typora-user-images\image-20231120183140384.png)

接着到mom里面去建立项目 然后写契约

这里面有接口契约 还有模型契约



接的工作就是写契约，同时要加一点小改动



day2 11.21

上午主要是写mom契约

再看看SOA的文档和mom



提一下意见：这个继承其实没有必要的，你是完全一比一的概念，因为你新建一个接口其实在模型里就会自动帮你创建好模型



然后类型要大写，包名要规范好



下午搞了搞MIT 考试



晚上做做需求

我的设计是：把这个POI拆成四种节点 基础信息 GEO 图片 其他

明天再来



day3 11.22

搭建POI标签的SOA服务



int改枚举

每个信息要给个poi 不然不知道哪个对应

其他图片要嵌套



接着进入代码部分

1、请求参数的校验

2、异常code定义

3、对异常的全局处理

4、日志写clog



James：我们不会让年轻人躺平，我们会让他们去旅游

现在有1w个应用，但是现在技术人员也才4000，生产数据是一共1400TB，所以数据治理相关工作需要开展





总结一下今晚的改进点

1、命名更加规范

2、写ut测试

3、代码里是不能出现中文的（注释要空格） 不要出现无意义的空行

4、逻辑写得不好

5、stream要判空

6、本地要能跑起来测试（加上断言、mock）



day4

今天继续完善SOA服务

先改改代码

首先全局异常处理是捕获不到的，因为我们基于@ControllerAdvice+@EXceptionHandler的原理呢是对Controller类进行一个加强，但是我们这个地方根本就没有controller只有service

因此你的全局异常捕获是肯定失效的





照着demo改一下代码

1、首先调整一下工程目录



http://conf.ctripcorp.com/pages/viewpage.action?pageId=1968746638



day6&7 来搞一下MIT EXAM



### Week2 12.27-12.3

这周主要是通过MIT实操和理论

接触一下公司的各种中间件和平台





**文档格式**

---sql优化

sql

应用场景

解决方案



sql如下：

告警：如下高频率执行SQL不满足性能要求

dicrawlerdb

![image-20231205124558537](D:\Users\haoxiang_zhang\AppData\Roaming\Typora\typora-user-images\image-20231205124558537.png)



1072410



CREATE TABLE `di_dna_user_portrait_requisition` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '空',
  `seq_no` varchar(50) DEFAULT NULL COMMENT '申请单号',
  `owner` varchar(50) DEFAULT NULL COMMENT '创建者',
  `app_id` varchar(50) DEFAULT NULL COMMENT '应用 id',
  `bu` varchar(50) DEFAULT NULL COMMENT '申请BU',
  `scene` varchar(2000) DEFAULT NULL COMMENT '使用场景',
  `online_date` date DEFAULT NULL COMMENT '上线时间',
  `status` varchar(50) DEFAULT NULL COMMENT '申请状态',
  `abroad` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否海外；0否，1是',
  `use_s` bit(1) NOT NULL DEFAULT b'1' COMMENT '是否使用s方法；0否，1是',
  `datachange_createtime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `datachange_lasttime` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
  `app_name` varchar(50) DEFAULT NULL COMMENT 'appid名称',
  `req_type` varchar(20) DEFAULT NULL COMMENT '申请类型',
  `des` varchar(2000) DEFAULT NULL COMMENT '申请理由',
  `approval_name` varchar(20) DEFAULT NULL COMMENT '审批人',
  `approval_time` datetime DEFAULT NULL COMMENT '审批时间',
  `approval_des` varchar(500) DEFAULT NULL COMMENT '审批意见',
  `app_effect` varchar(50) DEFAULT NULL COMMENT '衡量指标',
  `index_now` double DEFAULT NULL COMMENT '指标当前值',
  `index_target` double DEFAULT NULL COMMENT '预计提升至',
  `dsc_auth` varchar(10) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT 'dsc权限',
  `hive_account` varchar(200) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT 'Hive账号',
  `dsc_ticket_id` varchar(30) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT 'dsc申请单号',
  `hive_db_table` varchar(200) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT 'dsc申请的库名表名',
  PRIMARY KEY (`id`),
  UNIQUE KEY `seq_no` (`seq_no`),
  KEY `ChangeLastTime` (`datachange_lasttime`)
) ENGINE=InnoDB AUTO_INCREMENT=1799 DEFAULT CHARSET=utf8mb3 COMMENT='用户画像申请单'



排查：

先看了下建表语句发现没有索引

但通过count(*)发现表的行数并不算多，也就几千行，其实有无索引影响不大



这个sql优化我想了有两点

一是建索引 但数据行数很小

二是Like %%改成isnot null

原理：like%%需要进行模糊匹配，对字段的值进行逐个字符的比较，is not null直接对字段是否为空做判断



1、order by的字段要改 -- 改成lastTime

2、like 如果没有命中不要出现

3、distinct 的必要性

数据量很小其实 distinct没有必要 完全可以全部查出来 然后在java里处理



4、多联级的join不必要



5、索引建立起来

![image-20231205153625089](D:\Users\haoxiang_zhang\AppData\Roaming\Typora\typora-user-images\image-20231205153625089.png)





现在我们用dal框架来实现这个sql

目前要注意点：

1、我们肯定是不能该老的接口的



2、这里的业务肯定是要有select分页+count才能把整个完整的分页数据展现出来的



3、拆到dao层

即我们要有两个方法：

- 根据参数获取数据
- 根据参数算count总数



这里接一下:

它们之前封装的这个方法是用-来表示倒序 如果不加-就是正序



有个很大的问题是：

这里类 耦合得太死了 pojo里join写死了



![image-20231207144243902](D:\Users\haoxiang_zhang\AppData\Roaming\Typora\typora-user-images\image-20231207144243902.png)



sql调优思路：

select * 下来本地过滤处理，



代码处理：

1、optional优雅的进行NPE判断

2、代码里不要出现无关的常量

3、if的不必要性&如果有多个分支那要合并成一个

4、Stream判空



能做对象性就不要做基础性

关注一下业务逻辑



like不能被看到---stream filter性能更好

其实可以五条并发select *，然后到JVM内存去操作



其实还可以完全先过滤，因为最后要的只是t.*里的数据，最后再join

di_dna_user_portrait_label



两种方案设计：

1、在t表加两个关联字段 然后实现Join一次 但这种写法比较影响业务

2、localcache 把数据拉本地 然后用guava的本地缓存跑



**SQL慢查询优化方案**

1、在t表再加两个字段，因为我们其实最多能接受两张表的join

但要评估对代码的影响



2、引入本地缓存

因为表本身条数是不多的，可以拉下来到本地，然后在JVM里去操作

最后把结果存起来









表名有问题：

di_dna_user_portrait_application_labels --> di_dna_user_portrait_requisition_label

di_dna_user_portrait_requisition_label --> di_dna_user_portrait_label





DNA迁移到神农

接口在神农可以找到

http://cdp.fws.qa.nt.ctripcorp.com/web/dna/permission/applyList



1、owner字段空缺

DNAUser要封装





2、时间字段没封装上



3、labels字段没有

labels字段



4、subs字段没有

DNAUser参与人员

 

5、approve字段 

我们返回的申请记录里

有statue、和审核明细列表这两个字段



我们首先是根据dsc审核信息去更新申请记录状态status

然后对于每个申请去拿审核列表，取最新的数据封装数据



我们现在去看这个接口的业务属性，其实就是查看

用户画像的申请单



业务流程就是：根据当前user_name和搜索条件查找



其实找的申请就是

根据subs表的username 或是 t表的owner 来查找



那么其实就是根据subs表里的username找出seqno

然后去主表查

查出来后 封装一下label的List

最后过滤

然后排序、分页



目前两个问题

1. 性能还是太差 没有达到预期  
2. 修改数据时 localcache没有及时更新



针对问题一：主要是在构建label时每个都去查了sql 这导致1900个label发起了1900次的查询 这显然不合理 其次map的构建是固定的 应该放在缓存里



二、针对这个问题 

没有及时更新 原因还是在进行dal操作时 事务是需要时间的 我们马上去查数据库其实是查不到的



我们能不能直接在localCache里面改？





我们看修改记录时，页面刷新并没有把新的值带来，而db已经刷好了

接着我们再次更新第二条，我们发现第一条的修改生效了，这是因为回刷localcache的时候select出来了

我们分析这个问题：就是我们modify之后 紧接着去select发现是查不到更新的，从db角度来看



我们debug时发现 就是在这个方法里 我们重构缓存时其实db的数据没有改变 是我们这个业务方法结束后 事务提交 然后数据才更改,但是你会发现用Dal去操作就没有这个问题



我们这里有两个方案

一是显示提交update

二是我们主动更新localcache



封装过程

id缺失、bu缺失、



出现这个问题在于 封装回去时 没查出来 req_type被过滤了



scene字段缺少

approvalDes字段不对

approvalTime修改





还有个很有意思的点是：你会发现F12抓包发现 前1.7-1.8s是根本没有做事情的



new Code代码覆盖率

1、看看我们要改哪些UT

config包

cache包

vi包

util包

service包



res:upstream connect error or disconnect/reset before headers. reset reason: connection termination





![image-20240109160313753](D:\工作文档\assets\image-20240109160313753.png)

数据不太符合



### DNA排错

1、通过vi/health界面进去 发现是白的

这说明vi点火的流程都没有进行

猜测应该是拦截器的逻辑拦截了，重定向vi/health的时候，被SSO拦截了，



2、查询SSO文档，查看接入流程是否有问题，然后进行一些配置





3、为什么老版本没有呢？

很可能是新版本的vi加入了这一流程 触发了拦截 导致vi点火没有进行下去





4、过滤条件不足

加上标签名称/id的搜索



### DNA

发现前端页面没显示出来

两种可能：

1、permissionList没封装

2、前端自己控制 所以我们需要找到



{
  name: 'totallist',
  path: '/total/list',
  component: '../pages/total-record-list/index',
  authority: ['ADMIN'],
},这里看到前端是通过authority来控制菜单的显示



return checkAuthority(item.authority, currentUser.role, localItem, null) 前端抛异常 js抛异常

即比较菜单元素的authority和user的role是否匹配



所以迁的原因是因为

用户画像这个服务要从

















